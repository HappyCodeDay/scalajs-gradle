group 'scalajs'
version '1.0-SNAPSHOT'

apply plugin: 'groovy'
apply plugin: 'java'
apply plugin: 'scala'

import org.apache.tools.ant.taskdefs.condition.Os

import java.nio.file.Files

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

configurations {
    scalaCompilePlugin
}
dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.3.11'
    compile 'org.scala-lang:scala-library:2.11.7'
    compile group: 'org.scala-js', name: 'scalajs-cli_2.11', version: '0.6.7'
    compile group: 'org.scala-js', name: 'scalajs-library_2.11', version: '0.6.7'
    compile group: 'org.scala-js', name: 'scalajs-tools_2.11', version: '0.6.7'
    compile group: 'com.lihaoyi', name: 'scalatags_sjs0.6_2.11', version: '0.5.4'
    scalaCompilePlugin group: 'org.scala-js', name: 'scalajs-compiler_2.11.0', version: '0.6.7'
}

defaultTasks += 'compileJS'

def srcDir = 'src/main/scalajs/'
def sjsirDir = 'sjsir/'
def jsDir = 'js/'
def jsFile = jsDir + project.name + '.js'
def jsExecFile = jsDir + project.name + '_exec.js'

tasks.withType(ScalaCompile) {
    scalaCompileOptions.useAnt = false
    scalaCompileOptions.additionalParameters = ["-Xplugin:" + configurations.scalaCompilePlugin.asPath]
}

/**
 * Deletes a file, and if it is a folder, deletes it recursively.
 * @param file The file to be deleted
 * @return Unit
 */
def deleteFile(File file) {
    if (file.exists() && file.isDirectory()) {
        file.listFiles().each { deleteFile(it) }
        Files.delete(file.toPath())
    } else {
        Files.deleteIfExists(file.toPath())
    }
}

task cleanAll(dependsOn: 'clean') {
    description = "Deletes build, js and sjsir folders."
    doLast {
        def sjsirDirFile = new File(sjsirDir)
        def jsDirFile = new File(jsDir)
        deleteFile(sjsirDirFile)
        deleteFile(jsDirFile)
    }
}

task createDirs {
    description = "Creates necessary directories for compiling scalaJS."
    def sjsirDirFile = file(sjsirDir)
    if (!sjsirDirFile.exists()) {
        if (!sjsirDirFile.mkdir()) {
            logger.error('Couldn\'t create "' + sjsirDir + '" directory')
        }
    }
    def jsDirFile = file(jsDir)
    if (!jsDirFile.exists()) {
        if (!jsDirFile.mkdir()) {
            logger.error('Couldn\'t create "' + jsDir + '"directory')
        }
    }
    outputs.files(sjsirDirFile, jsDirFile)
    doFirst {
        logger.info('Creating directories...')
    }
    doLast {
        logger.info('Directories creation done')
    }
}

task compileSJSIR(type: ScalaCompile, dependsOn: 'createDirs') {
    description = "Compiles all scala files in src/main/scalajs/"
    source = files(srcDir)
    destinationDir = file(sjsirDir)
    classpath = configurations.compile
    logger.info("ScalaClasspath : " + scalaClasspath.files)
    scalaCompileOptions.incrementalOptions.analysisFile = new File("${buildDir}/tmp/scala/compilerAnalysis/compileCustomScala.analysis")
}

task compileJS(type: JavaExec, dependsOn: ['classes', 'compileSJSIR']) {
    description = "Compiles all sjsir files into a single javascript file"
    classpath = configurations.runtime
    classpath += sourceSets.main.runtimeClasspath
    main = 'Scalajsld'
    inputs.files(file(sjsirDir))
    outputs.file(file(jsFile))
    def argsL = new ArrayList<String>()
    argsL.add(file(sjsirDir).absolutePath)
    argsL.add(file(jsFile).absolutePath)
    classpath.filter{it.name.contains('scala')}.each{argsL.add(it.absolutePath)}
    args = argsL
}

task copyJS(dependsOn: 'compileJS', type: Copy) {
    description = "Copy the generated js file while renaming it with \'_exec.js\' at the end. Used by addMethExec for runJS.\n" +
            "Depends on compileJS."
    from(jsFile)
    into(jsDir)
    rename {
        String filename -> filename.replace('.js', '_exec.js')
    }
}
task addMethExec(dependsOn: 'copyJS') {
    description = "Adds the main exec at the end of the js file, given the object name, assuming function to run is \"main\" (default)\n" +
            "Depends on copyJS\n" +
            "Usage : \"gradlew addMainExec -Pclassname=\'nameOfClass\' -Pmethname=\'nameOfMethod\'"
    doFirst {
        if (!project.properties.containsKey('classname')) {
            logger.info('Skipping addMainExec : no classname given')
        } else {
            def js = file(jsExecFile)
            if (js.exists() && js.canWrite()) {
                def toAdd
                if (!project.properties.containsKey('methname')) {
                    toAdd = classname + '().main()'
                } else {
                    toAdd = classname + '().' + methname
                }
                logger.info('Adding ' + toAdd + ' at the end of the file.')
                js.append('\n' + toAdd)
                logger.info('Done')
            } else {
                logger.error('Couldn\'t find or write ' + js.path)
            }
        }
    }
}
task runJS(type: Exec, dependsOn: 'addMethExec') {
    description = "Runs the generated js file.\n" +
            "Depends on addMainExec.\n" + "Needs Node.js on PATH."
    def exec = Os.isFamily(Os.FAMILY_WINDOWS) ? 'cmd' : 'node'
    executable = exec

    args = exec == 'cmd' ? ['/C', 'node', jsExecFile] : [jsExecFile]
}